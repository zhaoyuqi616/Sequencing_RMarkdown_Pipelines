---
title: "Circular_Visualization_in_R"
output: html_document
---
## circlize package
Gu, Z. (2014) circlize implements and enhances circular visualization in R. Bioinformatics.[DOI: 10.1093/bioinformatics/btu393](https://academic.oup.com/bioinformatics/article/30/19/2811/2422259)  
Circular layout is very useful to represent complicated information.  
First, it elegantly represents information with long axes or a large amount of categories;  
Second, it intuitively shows data with multiple tracks focusing on the same object;   Third, it easily demonstrates relations between elements. It provides an efficient way to arrange information on the circle and it is beautiful.   
A circular layout is composed of sectors and tracks. For data in different categories, they are allocated into different sectors, and for multiple measurements on the same category, they are represented as stacked tracks from outside of the circle to the inside. The intersection of a sector and a track is called a cell (or a grid, a panel), which is the basic unit in a circular layout. It is an imaginary plotting region for drawing data points.  
Currently there are following low-level graphic functions that can be used for adding graphics. The usage is very similar to the functions without circos. prefix from the base graphic engine, except there are some enhancement specifically designed for circular visualization.
  
circos.points(): adds points in a cell.
circos.lines(): adds lines in a cell.
circos.segments(): adds segments in a cell.
circos.rect(): adds rectangles in a cell.
circos.polygon(): adds polygons in a cell.
circos.text(): adds text in a cell.
circos.axis() ands circos.yaxis(): add axis in a cell.
Following function draws links between two positions in the circle:
  
circos.link()
  
Following functions draw high-level graphics:
  
circos.barplot(): draw barplots.
circos.boxplot(): draw boxplots.
circos.violin(): draws violin plots.
circos.heatmap(): draw circular heatmaps.
circos.raster(): draw raster images.
circos.arrow(): draw circular arrows.
  
Following functions arrange the circular layout.
  
circos.initialize(): allocates sectors on the circle.
circos.track(): creates plotting regions for cells in one single track.
circos.update(): updates an existed cell.
circos.par(): graphic parameters.
circos.info(): prints general parameters of current circular plot.
circos.clear(): resets graphic parameters and internal variables.
  
The rule for making the circular plot is rather simple. It follows the sequence of initialize layout -> create track -> add graphics -> create track -> add graphics - ... -> clear. Graphics can be added at any time as long as the tracks are created.
  
```{r setup, include=TRUE}

knitr::opts_chunk$set(echo = TRUE)
library("circlize")
```
# A quick glance
First let’s generate some random data. There needs a character vector to represent categories, a numeric vector of x values and a vectoe of y values.
```{r A quick glance, include=TRUE}
set.seed(999)
n = 1000
df = data.frame(sectors = sample(letters[1:8], n, replace = TRUE),
    x = rnorm(n), y = runif(n))
circos.par("track.height" = 0.2)
circos.initialize(df$sectors, x = df$x)
circos.track(df$sectors, y = df$y,
    panel.fun = function(x, y) {
        circos.text(CELL_META$xcenter, 
            CELL_META$cell.ylim[2] + mm_y(5), 
            CELL_META$sector.index)
        circos.axis(labels.cex = 0.6)
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(df$sectors, df$x, df$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, "text", sector.index = "a", track.index = 1)
# Add histograms to the second track. Here circos.trackHist() is a high-level function which means it creates a new track.
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
# In the third track and in panel.fun, we randomly picked 10 data points in each cell, sort them by x-values and connect them with lines.
# In following code, when sectors (the first unnamed argument), x and y arguments are set in circos.track(), x values and y values are split by df$sectors and corresponding subset of x and y values are sent to panel.
# fun through panel.fun’s x and y arguments. Thus, x an y in panel.fun are exactly the values in the “current” cell.
circos.trackHist(df$sectors, df$x, bin.size = 0.2, bg.col = bgcol, col = NA)
circos.track(df$sectors, x = df$x, y = df$y,
    panel.fun = function(x, y) {
        ind = sample(length(x), 10)
        x2 = x[ind]
        y2 = y[ind]
        od = order(x2)
        circos.lines(x2[od], y2[od])
})
# Now we go back to the second track and update the cell in sector “d”. This is done by circos.updatePlotRegion() or the short version circos.update().
# The function erases graphics which have been added. circos.update() can not modify the xlim and ylim of the cell as well as other settings related to the position of the cell.
# circos.update() needs to explicitly specify the sector index and track index unless the “current” cell is what you want to update.
circos.update(sector.index = "d", track.index = 2, 
    bg.col = "#FF8080", bg.border = "black")
circos.points(x = -2:2, y = rep(0.5, 5), col = "white")
circos.text(CELL_META$xcenter, CELL_META$ycenter, "updated", col = "white")
# Next we continue to create new tracks. Although we have gone back to the second track, when creating a new track, the new track is still created after the track which is most inside.
# In this new track, we add heatmaps by circos.rect(). Note here we haven’t set the input data, while simply set ylim argument because heatmaps just fill the whole cell from the most left to right and from bottom to top.
# Also the exact value of ylim is not important and x, y in panel.fun() are not used (actually they are both NULL).
circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
    xlim = CELL_META$xlim
    ylim = CELL_META$ylim
    breaks = seq(xlim[1], xlim[2], by = 0.1)
    n_breaks = length(breaks)
    circos.rect(breaks[-n_breaks], rep(ylim[1], n_breaks - 1),
                breaks[-1], rep(ylim[2], n_breaks - 1),
                col = rand_color(n_breaks), border = NA)
})
# In the most inside of the circle, links or ribbons are added.
# There can be links from single point to point, point to interval or interval to interval. Section 3.11 gives detailed usage of links.
circos.link("a", 0, "b", 0, h = 0.4)
circos.link("c", c(-0.5, 0.5), "d", c(-0.5,0.5), col = "red",
    border = "blue", h = 0.2)
circos.link("e", 0, "g", c(-1,1), col = "green", border = "black", lwd = 2, lty = 2)
# Finally we need to reset the graphic parameters and internal variables, so that it will not mess up your next plot.
circos.clear()
```
```{r Similarity Circle, include=TRUE}
library(circlize)
category = paste0("category", "_", 1:9)
percent = sort(sample(40:80, 9))
color = rev(rainbow(length(percent)))


circos.par("start.degree" = 90, cell.padding = c(0, 0, 0, 0))
circos.initialize("a", xlim = c(0, 100)) # 'a` just means there is one sector
circos.track(ylim = c(0.5, length(percent)+0.5), track.height = 0.8, 
    bg.border = NA, panel.fun = function(x, y) {
        xlim = CELL_META$xlim
        circos.segments(rep(xlim[1], 9), 1:9,
                        rep(xlim[2], 9), 1:9,
                        col = "#CCCCCC")
        circos.rect(rep(0, 9), 1:9 - 0.45, percent, 1:9 + 0.45,
            col = color, border = "white")
        circos.text(rep(xlim[1], 9), 1:9, 
            paste(category, " - ", percent, "%"), 
            facing = "downward", adj = c(1.05, 0.5), cex = 0.8) 
        breaks = seq(0, 85, by = 5)
        circos.axis(h = "top", major.at = breaks, labels = paste0(breaks, "%"), 
            labels.cex = 0.6)
})
```
```{r Similarity Circle, include=TRUE}
library(circlize)

load(paste(system.file(package = "circlize"), "/extdata/DMR.RData", sep=""))

# rainfall
circos.initializeWithIdeogram(plotType = c("axis", "labels"))

bed_list = list(DMR_hyper, DMR_hypo)
circos.genomicRainfall(bed_list, pch = 16, cex = 0.4, col = c("#FF000080", "#0000FF80"))

circos.genomicDensity(bed_list[[1]], col = c("#FF000080"), track.height = 0.1)
circos.genomicDensity(bed_list[[2]], col = c("#0000FF80"), track.height = 0.1)
circos.clear()
```
To make is easy for Genomics analysis, circlize package particularly provides functions which focus on genomic plots. These functions are synonymous to the basic graphic functions but expect special format of input data:
  
circos.genomicTrack(): create a new track and add graphics.
circos.genomicPoints(): low-level function, add points.
circos.genomicLines(): low-level function, add lines or segments.
circos.genomicRect(): low-level function, add rectangles.
circos.genomicText(): low-level function, add text.
circos.genomicLink(): add links.  
The genomic functions are implemented by basic circlize functions (e.g. circos.track(), circos.points()), thus, the use of genomic functions can be mixed with the basic circlize functions.

##Applications in Genome  
```{r Applications in Genome, include=TRUE}
circos.initializeWithIdeogram()
text(0, 0, "hg38", cex = 1)
load(system.file(package = "circlize", "extdata", "DMR.RData"))
circos.initializeWithIdeogram(chromosome.index = paste0("chr", 1:22))

bed_list = list(DMR_hyper, DMR_hypo)
circos.genomicRainfall(bed_list, pch = 16, cex = 0.4, col = c("#FF000080", "#0000FF80"))
circos.genomicDensity(DMR_hyper, col = c("#FF000080"), track.height = 0.1)
circos.genomicDensity(DMR_hypo, col = c("#0000FF80"), track.height = 0.1)
```